// key.h -- Sodium Key Wrapper
//
// ISC License
// 
// Copyright (c) 2017 Farid Hajji <farid@hajji.name>
// 
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
// 
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#ifndef _S_KEY_H_
#define _S_KEY_H_

#include <vector>
#include <string>
#include <utility>
#include "common.h"
#include "alloc.h"

namespace Sodium {

  // Some common constants for typical key sizes from <sodium.h>
  static constexpr std::size_t KEYSIZE_SECRETBOX      = crypto_secretbox_KEYBYTES;
  static constexpr std::size_t KEYSIZE_AUTH           = crypto_auth_KEYBYTES;
  static constexpr std::size_t KEYSIZE_SALT           = crypto_pwhash_SALTBYTES;
  static constexpr std::size_t KEYSIZE_AEAD           = crypto_aead_chacha20poly1305_KEYBYTES;
  static constexpr std::size_t KEYSIZE_HASHKEY        = crypto_generichash_KEYBYTES;
  static constexpr std::size_t KEYSIZE_HASHKEY_MIN    = crypto_generichash_KEYBYTES_MIN;
  static constexpr std::size_t KEYSIZE_HASHKEY_MAX    = crypto_generichash_KEYBYTES_MAX;
  static constexpr std::size_t KEYSIZE_HASHSHORTKEY   = crypto_shorthash_KEYBYTES;
  static constexpr std::size_t KEYSIZE_PUBKEY         = crypto_box_PUBLICKEYBYTES;
  static constexpr std::size_t KEYSIZE_PRIVKEY        = crypto_box_SECRETKEYBYTES;
  static constexpr std::size_t KEYSIZE_SHAREDKEY      = crypto_box_BEFORENMBYTES;
  static constexpr std::size_t KEYSIZE_SEEDBYTES      = crypto_box_SEEDBYTES;
  static constexpr std::size_t KEYSIZE_PUBKEY_SIGN    = crypto_sign_PUBLICKEYBYTES;
  static constexpr std::size_t KEYSIZE_PRIVKEY_SIGN   = crypto_sign_SECRETKEYBYTES;
  static constexpr std::size_t KEYSIZE_SEEDBYTES_SIGN = crypto_sign_SEEDBYTES;
  static constexpr std::size_t KEYSIZE_CHACHA20       = crypto_stream_chacha20_KEYBYTES;
  static constexpr std::size_t KEYSIZE_XCHACHA20      = crypto_stream_xchacha20_KEYBYTES;
  static constexpr std::size_t KEYSIZE_SALSA20        = crypto_stream_salsa20_KEYBYTES;
  
template <std::size_t KEYSIZE=0>
class Key
{
  /**
   * The class Sodium::Key<KEYSIZE> represents a Key used in various
   * functions of the libsodium library.  Key material, being
   * particulary sensitive, is stored in "protected memory" using a
   * special allocator.
   *
   * A Key can be
   *   - default-constructed using random data,
   *   - default-constructed but left uninitialized
   *   - derived from a password string and a (hopefully random) salt.
   *
   * A Key can be made read-only or non-accessible when no longer
   * needed.  In general, it is a good idea to be as restrictive as
   * possible with key material.
   *
   * When a Key goes out of scope, it auto-destructs by zeroing its
   * memory, and eventually releasing the virtual pages too.
   **/

 public:
  
  /**
   * key_t is protected memory for bytes of key material (see: sodiumkey.h)
   *   * key_t memory will self-destruct/zero when out-of-scope / throws
   *   * key_t memory can be made readonly or temporarily non-accessible
   *   * key_t memory is stored in virtual pages protected by canary,
   *     guard pages, and access to those pages is granted with mprotect().
   **/
  
  using key_t      = std::vector<unsigned char, SodiumAlloc<unsigned char>>;
  
  // The strengh of the key derivation efforts for setpass()
  using strength_t = enum class Strength { low, medium, high };

  /**
   * Construct a Key of size KEYSIZE.
   *
   * If bool is true, initialize the key, i.e. fill it with random data
   * generated by initialize(), and then make it readonly().
   *
   * If bool is false, leave the key uninitialized, i.e. in the state
   * as created by the special allocator for protected memory. Leave
   * the key in the readwrite() default for further setpass()...
   **/
  
  explicit Key<KEYSIZE>(bool init=true) : keydata(KEYSIZE) {
    if (init) {
      initialize();
      readonly();
    }
    // CAREFUL: read/write uninitialized key
  }

  /**
   * Copy constructor for Keys
   * 
   * Note that copying a Key can be expensive, as the underlying keydata
   * needs to be copied as well, i.e. new key_t virtual pages need to
   * be allocated, mprotect()ed etc.
   * 
   * Consider using move semantics/constructor when passing Key(s) along
   * for better performance (see below).
   * 
   * Note that the copied Key will be readwrite(), even if the source
   * was readonly(). If you want a read-only copy, you'll have manually
   * set it to readonly() after it was copy-constructed.
   * 
   * If the source Key was noaccess(), this copy c'tor will terminate
   * the program.
   **/
  
  Key<KEYSIZE>(const Key<KEYSIZE> &other)             = default;
  Key<KEYSIZE>& operator=(const Key<KEYSIZE> &other)  = default;
  
  /**
   * A Key can be move-constructed and move-assigned from another
   * existing Key, thereby destroying that other Key along the way.
   * 
   * Move semantics for a Key means that the underlying keydata key_t
   * representation won't be unnecessarily duplicated / copied around;
   * saving us from creating virtual pages and mprotect()-ing them
   * when passing Key(s) around.
   * 
   * For move semantics to take effect, don't forget to use
   * either r-values for Key(s) when passing them to functions,
   * or convert Key l-values to r-values with std::move().
   * 
   * The following constructor / members implement move semantics for
   * Keys.
   **/
  
  Key<KEYSIZE>(Key<KEYSIZE> &&other) noexcept :
      keydata(0) {
	// temporarily create an empty key with 0 (i.e. keydata(0))
	// bytes (no allocation in key_t memory at all required) that
	// can be trivially destroyed; and swap that with other, that
	// will then be an empty shell.
	//
	// NOTE: other.size() will, after this, no more be KEYSIZE.
	std::swap(this->keydata, other.keydata);
  }

  Key<KEYSIZE>& operator=(Key<KEYSIZE> &&other) {
    this->keydata = std::move(other.keydata);
    return *this;
  }
    
  /**
   * Various libsodium functions used either directly or in
   * the wrappers need access to the bytes stored in the key.
   *
   * data() gives const access to those bytes of which
   * size() bytes are stored in the key.
   *
   * We don't provide mutable access to the bytes by design
   * with this data()/size() interface.
   * 
   * The only functions that change those bytes are:
   *   initialize(), destroy(), setpass().
   * 
   * !!!! IMPORTANT INVARIANT -- CHECK MANUALLY !!!!
   *
   * Note that we return KEYSIZE instead of keydata.size() in size()
   * so that size() can be declared constexpr and used in
   * static_assert() in callers.  We must make sure that the
   * invariant KEYSIZE == keydata.size() always holds when modifying
   * this class.
   * 
   * Even in the move constructor above, this is the case immediately
   * _after_ the constructor has finished constructing *this! (XXX).
   **/

            const unsigned char *data() const { return keydata.data(); }
  constexpr const std::size_t    size() const { return keydata.size(); }

  /**
   * Provide mutable access to the bytes of the key, so that users
   * can change / set them from the outside.
   *
   * It is the responsibility of the user to ensure that
   *   - the Key is set to readwrite(), if data is to be changed
   *   - no more than [setdata(), setdata()+size()) bytes are changed
   *     (or undefined behavior follows).
   * 
   * This function is primarily provided for the classes whose
   * underlying libsodium functions write the bytes of a Key directly,
   * like: 
   *   - KeyPair
   *   - CryptorMultiPK
   **/

  unsigned char *setdata() { return keydata.data(); }
    
  /**
   * Derive key material from the string password, and the salt
   * (where salt.size() == KEYSIZE_SALT) and store that key material
   * into this key object's protected readonly() memory.
   * 
   * The strength parameter determines how much effort is to be
   * put into the derivation of the key. It can be one of
   *    Key<KEYSIZE>::strength_t::{low,medium,high}.
   *
   * This function throws a std::runtime_error if the strength parameter
   * or the salt size don't make sense, or if the underlying libsodium
   * derivation function crypto_pwhash() runs out of memory.
   **/

  void setpass (const std::string &password,
		const data_t &salt,
		const strength_t strength = strength_t::high) {
    // check strength and set appropriate parameters
    unsigned long long strength_mem;
    unsigned long long strength_cpu;
    switch (strength) {
    case strength_t::low:
      strength_mem = crypto_pwhash_MEMLIMIT_INTERACTIVE;
      strength_cpu = crypto_pwhash_OPSLIMIT_INTERACTIVE;
      break;
    case strength_t::medium:
      strength_mem = crypto_pwhash_MEMLIMIT_MODERATE;
      strength_cpu = crypto_pwhash_OPSLIMIT_MODERATE;
      break;
    case strength_t::high:
      strength_mem = crypto_pwhash_MEMLIMIT_SENSITIVE;
      strength_cpu = crypto_pwhash_OPSLIMIT_SENSITIVE;
      break;
    default:
      throw std::runtime_error {"Sodium::Key<KEYSIZE>::setpass() wrong strength"};
    }

    // check salt length
    if (salt.size() != KEYSIZE_SALT)
      throw std::runtime_error {"Sodium::Key<KEYSIZE>::setpass() wrong salt size"};

    // derive a key from the hash of the password, and store it!
    readwrite(); // temporarily unlock the key (if not already)
    if (crypto_pwhash (keydata.data(), keydata.size(),
		       password.data(), password.size(),
		       salt.data(),
		       strength_cpu,
		       strength_mem,
		       crypto_pwhash_ALG_DEFAULT) != 0)
      throw std::runtime_error {"Sodium::Key<KEYSIZE>::setpass() crypto_pwhash()"};
    readonly(); // relock the key
  }

  /**
   * Initialize, i.e. fill with random data generated with libsodium's
   * function randombytes_buf() the number of bytes already allocated
   * to this Key upon construction.
   *
   * You normally don't need to call this function yourself, as it is
   * called by Key's constructor. It is provided as a public function
   * nonetheless, should you need to rescramble the key, keeping its
   * size (a rare case).
   *
   * This function will terminate the program if the Key is readonly()
   * or noaccess() on systems that enforce mprotect().
   **/
  
  void initialize() {
    randombytes_buf(keydata.data(), keydata.size());
  }

  /**
   * Destroy the bytes stored in protected memory of this key by
   * attempting to zeroing them.
   *
   * A Key that has been destroy()ed still holds size() zero-bytes in
   * protected memory, and can thus be reused, i.e. reset by calling
   * e.g. setpass().
   *
   * The key will be destroyed, even if it has been set readonly()
   * or noaccess() previously.
   * 
   * You normally don't need to explicitely zero a Key, because Keys
   * self-destruct (including zeroing their bytes) when they go out
   * of scope. This function is provided in case you need to immediately
   * erase a Key anyway (think: Panic Button).
   **/
  
  void destroy() {
    readwrite();
    sodium_memzero(keydata.data(), keydata.size());
  }

  /**
   * Mark this Key as non-accessible. All attempts to read or write
   * to this key will be caught by the CPU / operating system and
   * will result in abnormal program termination.
   * 
   * The protection mechanism works by mprotect()ing the virtual page
   * containing the key bytes accordingly.
   *
   * Note that the key bytes are still available, even when noaccess()
   * has been called. Restore access by calling readonly() or readwrite().
   **/
  
  void noaccess()  { keydata.get_allocator().noaccess(keydata.data()); }

  /**
   * Mark this Key as read-only. All attemps to write to this key will
   * be caught by the CPU / operating system and will result in abnormal
   * program termination.
   *
   * The protection mechanism works by mprotect()ing the virtual page
   * containing the key bytes accordingly.
   *
   * Note that the key bytes can be made writable by calling readwrite().
   **/
  
  void readonly()  { keydata.get_allocator().readonly(keydata.data()); }

  /**
   * Mark this Key as read/writable. Useful after it has been previously
   * marked readonly() or noaccess().
   **/

  void readwrite() { keydata.get_allocator().readwrite(keydata.data()); }

 private:
  key_t keydata; // the bytes of the key are stored in protected memory
};
 
} // namespace Sodium

template <std::size_t KEYSIZE1, std::size_t KEYSIZE2>
  bool operator== (const Sodium::Key<KEYSIZE1> &k1,
		   const Sodium::Key<KEYSIZE2> &k2)
{
  // Don't do this (side channel attack):
  // std::equal(k1.data(), k1.data() + k1.size(),
  //            k2.data());
  
  // compare two keys in constant time instead:
  return (k1.size() == k2.size())
    &&
  (sodium_memcmp(k1.data(), k2.data(), k1.size()) == 0);
}

template <std::size_t KEYSIZE1, std::size_t KEYSIZE2>
  bool operator!= (const Sodium::Key<KEYSIZE1> &k1,
		   const Sodium::Key<KEYSIZE2> &k2)
{
  return (! (k1 == k2));
}

#endif // _S_KEY_H_
