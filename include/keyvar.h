// keyvar.h -- Sodium Key Wrapper, Key(s) with variable length at runtime
//
// ISC License
// 
// Copyright (c) 2017 Farid Hajji <farid@hajji.name>
// 
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
// 
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#ifndef _S_KEYVAR_H_
#define _S_KEYVAR_H_

#include <vector>
#include <string>
#include <utility>
#include "common.h"
#include "alloc.h"
#include "key.h"     // for KEYSIZE constants

namespace Sodium {

class KeyVar
{
  /**
   * The class Sodium::KeyVar represents a Key used in various functions
   * of the libsodium library.  Key material, being particulary sensitive,
   * is stored in "protected memory" using a special allocator.
   *
   * A KeyVar can be
   *   - default-constructed using random data,
   *   - default-constructed but left uninitialized
   *   - derived from a password string and a (hopefully random) salt.
   *
   * A KeyVar can be made read-only or non-accessible when no longer
   * needed.  In general, it is a good idea to be as restrictive as
   * possible with key material.
   *
   * When a KeyVar goes out of scope, it auto-destructs by zeroing its
   * memory, and eventually releasing the virtual pages too.
   **/

 public:
  
  /**
   * key_t is protected memory for bytes of key material (see: sodiumkey.h)
   *   * key_t memory will self-destruct/zero when out-of-scope / throws
   *   * key_t memory can be made readonly or temporarily non-accessible
   *   * key_t memory is stored in virtual pages protected by canary,
   *     guard pages, and access to those pages is granted with mprotect().
   **/
  
  using key_t      = std::vector<unsigned char, SodiumAlloc<unsigned char>>;
  
  // The strengh of the key derivation efforts for setpass()
  using strength_t = enum class Strength { low, medium, high };

  /**
   * Construct a KeyVar of size key_size.
   *
   * If bool is true, initialize the key, i.e. fill it with random data
   * generated by initialize(), and then make it readonly().
   *
   * If bool is false, leave the key uninitialized, i.e. in the state
   * as created by the special allocator for protected memory. Leave
   * the key in the readwrite() default for further setpass()...
   **/
  
  KeyVar(std::size_t key_size, bool init=true) : keydata(key_size) {
    if (init) {
      initialize();
      readonly();
    }
    // CAREFUL: read/write uninitialized key
  }

  /**
   * Copy constructor for KeyVars
   * 
   * Note that copying a KeyVar can be expensive, as the underlying keydata
   * needs to be copied as well, i.e. new key_t virtual pages need to
   * be allocated, mprotect()ed etc.
   * 
   * Consider using move semantics/constructor when passing KeyVar(s)
   * along for better performance (see below).
   * 
   * Note that the copied KeyVar will be readwrite(), even if the
   * source was readonly(). If you want a read-only copy, you'll have
   * manually set it to readonly() after it was copy-constructed.
   * 
   * If the source KeyVar was noaccess(), this copy c'tor will
   * terminate the program.
   **/
  
  KeyVar(const KeyVar &other)             = default;
  KeyVar& operator=(const KeyVar &other)  = default;
  
  /**
   * A KeyVar can be move-constructed and move-assigned from another
   * existing KeyVar, thereby destroying that other KeyVar along the
   * way.
   * 
   * Move semantics for a KeyVar means that the underlying keydata
   * key_t representation won't be unnecessarily duplicated / copied
   * around; saving us from creating virtual pages and mprotect()-ing
   * them when passing KeyVar(s) around.
   * 
   * For move semantics to take effect, don't forget to use
   * either r-values for KeyVar(s) when passing them to functions,
   * or convert KeyVar l-values to r-values with std::move().
   * 
   * The following constructor / members implement move semantics for
   * KeyVars.
   **/
  
  KeyVar() : keydata(0) {
    // leave readwrite()
  }

  KeyVar(KeyVar &&other) noexcept :
    KeyVar {} {
      std::swap(this->keydata, other.keydata);
  }

  KeyVar& operator=(KeyVar &&other) {
    this->keydata = std::move(other.keydata);
    return *this;
  }
    
  /**
   * Various libsodium functions used either directly or in
   * the wrappers need access to the bytes stored in the keyvar.
   *
   * data() gives const access to those bytes of which
   * size() bytes are stored in the keyvar.
   *
   * We don't provide mutable access to the bytes by design
   * with this data()/size() interface.
   * 
   * The only functions that change those bytes are:
   *   initialize(), destroy(), setpass().
   **/

  const unsigned char *data() const { return keydata.data(); }
  const std::size_t    size() const { return keydata.size(); }

  /**
   * Provide mutable access to the bytes of the keyvar, so that users
   * can change / set them from the outside.
   *
   * It is the responsibility of the user to ensure that
   *   - the KeyVar is set to readwrite(), if data is to be changed
   *   - no more than [setdata(), setdata()+size()) bytes are changed
   * 
   * This function is primarily provided for the classes whose
   * underlying libsodium functions write the bytes of a KeyVar directly,
   * like: 
   *   - KeyPair
   *   - CryptorMultiPK
   * 
   * CAVEAT: Currently, KeyPair and CryptorMultiPK use Key<...> instead
   *         of KeyVar. But we leave this functionality in place in case
   *         it is needed.
   **/

  unsigned char *setdata() { return keydata.data(); }
    
  /**
   * Derive key material from the string password, and the salt
   * (where salt.size() == KEYSIZE_SALT) and store that key material
   * into this key object's protected readonly() memory.
   * 
   * The strength parameter determines how much effort is to be
   * put into the derivation of the key. It can be one of
   *    KeyVar::strength_t::{low,medium,high}.
   *
   * This function throws a std::runtime_error if the strength parameter
   * or the salt size don't make sense, or if the underlying libsodium
   * derivation function crypto_pwhash() runs out of memory.
   **/

  void setpass (const std::string &password,
		const data_t &salt,
		const strength_t strength = strength_t::high) {
    // check strength and set appropriate parameters
    std::size_t strength_mem;
    unsigned long long strength_cpu;
    switch (strength) {
    case strength_t::low:
      strength_mem = crypto_pwhash_MEMLIMIT_INTERACTIVE;
      strength_cpu = crypto_pwhash_OPSLIMIT_INTERACTIVE;
      break;
    case strength_t::medium:
      strength_mem = crypto_pwhash_MEMLIMIT_MODERATE;
      strength_cpu = crypto_pwhash_OPSLIMIT_MODERATE;
      break;
    case strength_t::high:
      strength_mem = crypto_pwhash_MEMLIMIT_SENSITIVE;
      strength_cpu = crypto_pwhash_OPSLIMIT_SENSITIVE;
      break;
    default:
      throw std::runtime_error {"Sodium::KeyVar::setpass() wrong strength"};
    }

    // check salt length
    if (salt.size() != KEYSIZE_SALT)
      throw std::runtime_error {"Sodium::KeyVar::setpass() wrong salt size"};

    // derive a key from the hash of the password, and store it!
    readwrite(); // temporarily unlock the key (if not already)
    if (crypto_pwhash (keydata.data(), keydata.size(),
		       password.data(), password.size(),
		       salt.data(),
		       strength_cpu,
		       strength_mem,
		       crypto_pwhash_ALG_DEFAULT) != 0)
      throw std::runtime_error {"Sodium::KeyVar::setpass() crypto_pwhash()"};
    readonly(); // relock the key
  }

  /**
   * Initialize, i.e. fill with random data generated with libsodium's
   * function randombytes_buf() the number of bytes already allocated
   * to this KeyVar upon construction.
   *
   * You normally don't need to call this function yourself, as it is
   * called by KeyVar's constructor. It is provided as a public function
   * nonetheless, should you need to rescramble the key, keeping its
   * size (a rare case).
   *
   * This function will terminate the program if the KeyVar is readonly()
   * or noaccess() on systems that enforce mprotect().
   **/
  
  void initialize() {
    randombytes_buf(keydata.data(), keydata.size());
  }

  /**
   * Destroy the bytes stored in protected memory of this key by
   * attempting to zeroing them.
   *
   * A KeyVar that has been destroy()ed still holds size() zero-bytes in
   * protected memory, and can thus be reused, i.e. reset by calling
   * e.g. setpass().
   *
   * The KeyVar will be destroyed, even if it has been set readonly()
   * or noaccess() previously.
   * 
   * You normally don't need to explicitely zero a KeyVar, because
   * KeyVars self-destruct (including zeroing their bytes) when they
   * go out of scope. This function is provided in case you need to
   * immediately erase a KeyVar anyway (think: Panic Button).
   **/
  
  void destroy() {
    readwrite();
    sodium_memzero(keydata.data(), keydata.size());
  }

  /**
   * Mark this KeyVar as non-accessible. All attempts to read or write
   * to this key will be caught by the CPU / operating system and
   * will result in abnormal program termination.
   * 
   * The protection mechanism works by mprotect()ing the virtual page
   * containing the key bytes accordingly.
   *
   * Note that the key bytes are still available, even when noaccess()
   * has been called. Restore access by calling readonly() or readwrite().
   **/
  
  void noaccess()  { keydata.get_allocator().noaccess(keydata.data()); }

  /**
   * Mark this KeyVar as read-only. All attemps to write to this key will
   * be caught by the CPU / operating system and will result in abnormal
   * program termination.
   *
   * The protection mechanism works by mprotect()ing the virtual page
   * containing the key bytes accordingly.
   *
   * Note that the key bytes can be made writable by calling readwrite().
   **/
  
  void readonly()  { keydata.get_allocator().readonly(keydata.data()); }

  /**
   * Mark this KeyVar as read/writable. Useful after it has been
   * previously marked readonly() or noaccess().
   **/

  void readwrite() { keydata.get_allocator().readwrite(keydata.data()); }

 private:
  key_t keydata; // the bytes of the key are stored in protected memory
};
 
} // namespace Sodium

extern bool operator== (const Sodium::KeyVar &k1, const Sodium::KeyVar &k2);
extern bool operator!= (const Sodium::KeyVar &k1, const Sodium::KeyVar &k2);

#endif // _S_KEYVAR_H_
