// keypairsign.h -- Public/Private Signing Key Pair Wrapper
//
// ISC License
// 
// Copyright (C) 2018 Farid Hajji <farid@hajji.name>
// 
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
// 
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#pragma once

#include "key.h"

namespace sodium {

template <typename PK=bytes>
class keypairsign
{
  /**
   * The class sodium::keypairsign represents a pair of public key /
   * private key used for public key signatures in various public key
   * cryptography functions of the libsodium library.
   *
   * The public key is stored in unprotected (bytes) memory, while
   * the private key, being sensitive, is stored in protected
   * (bytes_protected) memory, i.e. in an internal key object.
   *
   * A keypairsign provides non-mutable data()/size() access to the
   * bytes of the public/private keys in a uniform fashion via the
   * public_key() and private_key() accessors.
   *
   * A key pair can be constructed randomly, or deterministically by
   * providing a seed. Furthermore, given a private key previously
   * generated by keypairsign or the underlying libsodium functions,
   * the corresponding public key and the seed can be derived and a
   * keypairsign constructed.
   **/

 public:
  // common constants for typical key and seed sizes
  static constexpr std::size_t KEYSIZE_PUBLIC_KEY  = crypto_sign_PUBLICKEYBYTES;
  static constexpr std::size_t KEYSIZE_PRIVATE_KEY = crypto_sign_SECRETKEYBYTES;
  static constexpr std::size_t KEYSIZE_SEEDBYTES = crypto_sign_SEEDBYTES;

  using private_key_type = key<KEYSIZE_PRIVATE_KEY>;
  using public_key_type = PK;
  
  /**
   * Generate a new (random) key pair of public/private signing keys.
   *
   * The created keypairsign contains a public key with KEYSIZE_PUBLIC_KEY bytes,
   * and a private key with KEYSIZE_PRIVATE_KEY bytes. Both keys are related
   * and must be used together.
   *
   * Underlying libsodium function: crypto_sign_keypair().
   *
   * the private key is stored in an internal key object in bytes_protected
   * memory (readonly). It will be wiped clean when the keypairsign
   * goes out of scope or is destroyed.
   *
   * The public key is stored in an internal bytes object in
   * unprotected (readwrite) memory.
   **/
  
  keypairsign()
    : public_key_(KEYSIZE_PUBLIC_KEY, '\0'), private_key_(false) {
    if (crypto_sign_keypair(reinterpret_cast<unsigned char *>(public_key_.data()), private_key_.setdata()) == -1)
      throw std::runtime_error {"sodium::keypairsign::keypairsign() crypto_sign_keypair() -1"};
    
    private_key_.readonly();
  }

  /**
   * Deterministically generate a key pair of public/private signing keys.
   *
   * The created keypairsign depends on a seed which must have
   * KEYSIZE_SEEDBYTES bytes. The same public/private keys will be
   * generated for the same seeds. Providing a seed of wrong size will
   * throw a std::runtime_error.
   *
   * Underlying libsodium function: crypto_sign_seed_keypair().
   *
   * Otherwise, see keypairsign().
   **/
  
  keypairsign(const bytes &seed)
    : public_key_(KEYSIZE_PUBLIC_KEY, '\0'), private_key_(false) {
    if (seed.size() != KEYSIZE_SEEDBYTES)
      throw std::runtime_error {"sodium::keypairsign::keypairsign(seed) wrong seed size"};

    if (crypto_sign_seed_keypair(reinterpret_cast<unsigned char *>(public_key_.data()),
		         private_key_.setdata(),
				 seed.data()) == -1)
      throw std::runtime_error {"sodium::keypairsign::keypairsign(seed...) crypto_sign_seed_keypair() -1"};
    
    private_key_.readonly();
  }

  /**
   * Given a previously calculated private key whose private_key_size
   * bytes are stored starting at private_key_data, derive the
   * corresponding public key public_key, and construct with private_key_data
   * and public_key a new keypairsign. private_key_data MUST point to
   * KEYSIZE_PRIVATE_KEY bytes as shown by private_key_size, of course, or
   * this constructor will throw a std::runtime_error. The bytes at
   * private_key_data must be accessible or readable, or the program will
   * terminate.
   *
   * Underlying libsodium function: crypto_sign_ed25519_sk_to_pk()
   *
   * Note that the bytes at private_key_data MUST have been generated by
   * calculation, i.e. by calls to keypairsign() constructors or
   * underlying libsodium functions. Undefined behavior results if
   * this is not the case.
   *
   * Otherwise, see keypairsign().
   **/
  
  keypairsign(const byte *private_key_data,
	      const std::size_t private_key_size)
    : public_key_(KEYSIZE_PUBLIC_KEY, '\0'), private_key_(false) {
    if (private_key_size != KEYSIZE_PRIVATE_KEY)
      throw std::runtime_error {"sodium::keypairsign::keypairsign(private_key_data, private_key_size) wrong private_key_size"};
    std::copy(private_key_data, private_key_data+private_key_size,
	      private_key_.setdata());

    // reconstruct public_key from private_key
    if (crypto_sign_ed25519_sk_to_pk(reinterpret_cast<unsigned char *>(public_key_.data()), private_key_.data()) == -1)
      throw std::runtime_error {"sodium::keypairsign::keypairsign(private_key_data...) crypto_sign_ed25519_sk_to_pk -1"};

    private_key_.readonly();
  }

  /**
  * Copy and move constructors
  **/

  template <typename U>
  keypairsign(const keypairsign<U> &other) :
	  public_key_(other.public_key()),
	  private_key_(other.private_key())
  {}

  template <typename U>
  keypairsign(keypairsign<U> &&other) :
	  public_key_(std::move other.public_key_),
	  private_key_(std::move other.private_key_)
  {}

  /**
   * Return the seed corresponding to the private key stored in
   * this KeyPairSign.
   *
   * Underlying libsodium function: crypto_sign_ed25519_sk_to_seed()
   **/

  bytes seed() {
    bytes the_seed(KEYSIZE_SEEDBYTES);
    if (crypto_sign_ed25519_sk_to_seed(reinterpret_cast<unsigned char *>(the_seed.data()),
				       private_key_.data()) == -1)
      throw std::runtime_error {"sodium::keypairsign::seed() crypto_sign_ed25519_sk_to_seed() -1"};
    
    return the_seed;
  }
  
  /**
   * Give const access to the stored private key as a key object.
   *
   * This can be used to access the bytes of the private key via a
   * non-mutable data()/size() interface like this:
   *   <SOME_KEYPAIR>.private_key().data(), <SOME_KEYPAIR>.private_key().size()
   **/

  const private_key_type private_key() const { return private_key_; }

  /**
   * Give const access to the stored public key as a bytes object.
   *
   * This can be used to access the bytes of the public key via a
   * non-mutable data()/size() interface like this:
   *  <SOME_KEYPAIR>.public_key().data(), <SOME_KEYPAIR>.public_key().size()
   **/

  const public_key_type public_key() const { return public_key_; }
  
 private:
  public_key_type public_key_;
  private_key_type private_key_;
};

} // namespace sodium

template <typename PK1, typename PK2>
bool operator== (const sodium::keypairsign<PK1> &kp1,
	const sodium::keypairsign<PK2> &kp2)
{
	// Compare public keys and private keys in constant time:

	return
		// selects sodium::compare<PK1,PK2>()
		sodium::compare(kp1.public_key(), kp2.public_key())
		&&
		// uses operator==(sodium::key<KEYSIZE_PRIVATE_KEY>,
		//                 sodium::key<KEYSIZE_PRIVATE_KEY>)
		kp1.private_key() == kp2.private_key();
}

template <typename PK1, typename PK2>
bool operator!= (const sodium::keypairsign<PK1> &kp1,
	const sodium::keypairsign<PK2> &kp2)
{
	return (!(kp1 == kp2));
}
